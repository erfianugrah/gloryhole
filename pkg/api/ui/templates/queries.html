{{template "base.html" .}}

{{define "title"}}Query Log - Gloryhole{{end}}

{{define "content"}}
<div class="queries-page">
    <div class="page-header">
        <h2>Query Log</h2>

        <!-- Quick Time Range Buttons -->
        <div class="time-range-buttons" style="margin-bottom: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
            <button class="btn btn-secondary btn-sm" type="button" data-time-range="1h">Last Hour</button>
            <button class="btn btn-secondary btn-sm" type="button" data-time-range="24h">Last 24 Hours</button>
            <button class="btn btn-secondary btn-sm" type="button" data-time-range="7d">Last 7 Days</button>
            <button class="btn btn-secondary btn-sm" type="button" data-time-range="custom">Custom</button>
        </div>

        <form id="query-filter-form" class="filters" autocomplete="off">
            <input type="text" id="filter-domain" name="domain" placeholder="Filter by domain..." class="filter-input">
            <input type="text" id="filter-client" name="client" placeholder="Filter by client IP..." class="filter-input">
            <input type="text" id="filter-upstream" name="upstream" placeholder="Filter by upstream..." class="filter-input">
            <select id="filter-type" name="type" class="filter-select">
                <option value="">All Types</option>
                <option value="A">A</option>
                <option value="AAAA">AAAA</option>
                <option value="CNAME">CNAME</option>
                <option value="MX">MX</option>
                <option value="PTR">PTR</option>
                <option value="TXT">TXT</option>
            </select>
            <select id="filter-status" name="status" class="filter-select">
                <option value="">All Queries</option>
                <option value="blocked">Blocked Only</option>
                <option value="allowed">Allowed Only</option>
                <option value="cached">Cached Only</option>
            </select>
            <select id="filter-rcode" name="rcode" class="filter-select">
                <option value="">All Response Codes</option>
                <option value="0">0 - NOERROR</option>
                <option value="2">2 - SERVFAIL</option>
                <option value="3">3 - NXDOMAIN</option>
                <option value="5">5 - REFUSED</option>
            </select>
            <input type="datetime-local" id="filter-start" name="start" class="filter-input" placeholder="Start time" style="display: none;">
            <input type="datetime-local" id="filter-end" name="end" class="filter-input" placeholder="End time" style="display: none;">
            <button class="btn btn-secondary btn-sm" type="button" data-reset-filters>Reset</button>
            <div class="is-visually-hidden">
                <input type="hidden" name="limit" id="queries-limit" value="20">
                <input type="hidden" name="offset" id="queries-offset" value="0">
            </div>
        </form>
    </div>

    <div id="queries-container"
         hx-get="/api/ui/queries"
         hx-trigger="load delay:100ms, every 6s, filters-changed, refresh"
         hx-swap="morph"
         hx-ext="idiomorph"
         hx-indicator="#queries-loading"
         hx-include="#query-filter-form">
        <div class="skeleton-loader">
            <table class="queries-table">
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Client</th>
                        <th>Domain</th>
                        <th>Type</th>
                        <th>Status</th>
                        <th>Code</th>
                        <th>Upstream</th>
                        <th>Latency</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="skeleton-row"><td colspan="8"><div class="skeleton-line"></div></td></tr>
                    <tr class="skeleton-row"><td colspan="8"><div class="skeleton-line"></div></td></tr>
                    <tr class="skeleton-row"><td colspan="8"><div class="skeleton-line"></div></td></tr>
                    <tr class="skeleton-row"><td colspan="8"><div class="skeleton-line"></div></td></tr>
                    <tr class="skeleton-row"><td colspan="8"><div class="skeleton-line"></div></td></tr>
                </tbody>
            </table>
        </div>
    </div>
    <div id="queries-loading" class="hx-indicator">Refreshingâ€¦</div>

    <div class="pagination" id="queries-pagination">
        <button id="prev-btn" class="btn btn-secondary" type="button" data-page-shift="-1">Previous</button>
        <span id="page-info" style="margin: 0 1rem;">Page <span id="current-page">1</span></span>
        <button id="next-btn" class="btn btn-secondary" type="button" data-page-shift="1">Next</button>
    </div>
</div>

<script>
window.addEventListener('DOMContentLoaded', function () {
    const container = document.getElementById('queries-container');
    const filterForm = document.getElementById('query-filter-form');
    const limitInput = document.getElementById('queries-limit');
    const offsetInput = document.getElementById('queries-offset');
    const pageLabel = document.getElementById('current-page');
    const prevBtn = document.getElementById('prev-btn');
    const resetBtn = document.querySelector('[data-reset-filters]');
    const pageButtons = document.querySelectorAll('[data-page-shift]');
    const timeRangeButtons = document.querySelectorAll('[data-time-range]');
    const startInput = document.getElementById('filter-start');
    const endInput = document.getElementById('filter-end');
    const hx = window.htmx;
    let filterTimer = null;

    function updatePaginationControls() {
        const limit = Number(limitInput?.value) || 1;
        const offset = Number(offsetInput?.value) || 0;
        const currentPage = Math.floor(offset / limit) + 1;
        if (pageLabel) {
            pageLabel.textContent = currentPage;
        }
        if (prevBtn) {
            prevBtn.disabled = offset === 0;
        }
    }

    function triggerRefresh(eventName) {
        if (!container || !hx) {
            return;
        }
        hx.trigger(container, eventName || 'refresh');
    }

    function shiftPage(deltaPages) {
        const limit = Number(limitInput?.value) || 20;
        const offset = Number(offsetInput?.value) || 0;
        const nextOffset = Math.max(0, offset + deltaPages * limit);
        if (nextOffset === offset && nextOffset === 0 && deltaPages < 0) {
            return;
        }
        offsetInput.value = String(nextOffset);
        updatePaginationControls();
        triggerRefresh('refresh');
    }

    pageButtons.forEach((button) => {
        button.addEventListener('click', () => {
            const delta = Number(button.dataset.pageShift) || 0;
            shiftPage(delta);
        });
    });

    function scheduleFilterRefresh() {
        if (!offsetInput) {
            return;
        }
        offsetInput.value = '0';
        updatePaginationControls();
        if (filterTimer) {
            window.clearTimeout(filterTimer);
        }
        filterTimer = window.setTimeout(() => triggerRefresh('filters-changed'), 250);
    }

    filterForm?.addEventListener('input', scheduleFilterRefresh);
    filterForm?.addEventListener('change', scheduleFilterRefresh);

    // Client-side sorting for the rendered table using data-* attributes from the partial
    function sortTable(key) {
        const table = container?.querySelector('.queries-table');
        if (!table) return;
        const tbody = table.querySelector('tbody');
        if (!tbody) return;
        const rows = Array.from(tbody.querySelectorAll('tr')).filter((row) => row.dataset && row.dataset.domain !== undefined);
        if (!rows.length) return;

        const currentKey = table.dataset.sortKey;
        const currentDir = table.dataset.sortDir || 'asc';
        const nextDir = currentKey === key && currentDir === 'asc' ? 'desc' : 'asc';
        table.dataset.sortKey = key;
        table.dataset.sortDir = nextDir;

        const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });
        rows.sort((a, b) => {
            const va = a.dataset[key] || '';
            const vb = b.dataset[key] || '';
            if (key === 'timestamp' || key === 'latency' || key === 'upstream' || key === 'rcode') {
                const na = parseFloat(va) || 0;
                const nb = parseFloat(vb) || 0;
                return nextDir === 'asc' ? na - nb : nb - na;
            }
            return nextDir === 'asc' ? collator.compare(va, vb) : collator.compare(vb, va);
        });

        tbody.innerHTML = '';
        rows.forEach((row) => tbody.appendChild(row));
    }

    function attachSortHandlers() {
        const table = container?.querySelector('.queries-table');
        if (!table) return;
        const headers = table.querySelectorAll('th');
        const map = ['timestamp','client','domain','type','status','rcode','upstream','latency'];
        headers.forEach((th, idx) => {
            const key = map[idx];
            if (!key) return;
            // Only add sortable class and event listener if not already added
            if (!th.classList.contains('sortable')) {
                th.classList.add('sortable');
                th.addEventListener('click', () => sortTable(key));
            }
        });
    }

    document.addEventListener('htmx:afterSwap', (event) => {
        if (event.target === container) {
            attachSortHandlers();
        }
    });

    attachSortHandlers();

    // Time range button handlers
    timeRangeButtons.forEach((button) => {
        button.addEventListener('click', () => {
            const range = button.dataset.timeRange;
            const now = new Date();
            let start;

            if (range === 'custom') {
                // Show datetime inputs
                startInput.style.display = '';
                endInput.style.display = '';
                startInput.value = '';
                endInput.value = '';
                return;
            }

            // Hide datetime inputs for preset ranges
            startInput.style.display = 'none';
            endInput.style.display = 'none';

            // Calculate start time based on range
            switch (range) {
                case '1h':
                    start = new Date(now.getTime() - 60 * 60 * 1000);
                    break;
                case '24h':
                    start = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                    break;
                case '7d':
                    start = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    break;
            }

            if (start) {
                // Format as datetime-local value
                const formatDateTime = (date) => {
                    const pad = (n) => n.toString().padStart(2, '0');
                    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
                };
                startInput.value = formatDateTime(start);
                endInput.value = formatDateTime(now);
                scheduleFilterRefresh();
            }
        });
    });

    resetBtn?.addEventListener('click', () => {
        filterForm?.reset();
        startInput.style.display = 'none';
        endInput.style.display = 'none';
        scheduleFilterRefresh();
    });

    document.addEventListener('htmx:configRequest', (event) => {
        if (event.target !== container) {
            return;
        }
        const params = event.detail?.parameters;
        if (!params) {
            return;
        }
        ['start', 'end'].forEach((key) => {
            if (params[key]) {
                const normalized = normalizeDateValue(params[key]);
                if (normalized) {
                    params[key] = normalized;
                } else {
                    delete params[key];
                }
            }
        });
    });

    function normalizeDateValue(value) {
        if (!value) {
            return '';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
            return '';
        }
        return date.toISOString();
    }

    updatePaginationControls();
});
</script>
{{end}}

{{template "base.html" .}}

{{define "title"}}Settings - Gloryhole{{end}}

{{define "settings-upstreams"}}
{{$cfg := .Config}}
<div class="settings-section" id="upstreams-section">
    <h3>Upstream DNS Servers</h3>
    <p class="section-description">Control which recursive resolvers Gloryhole uses when forwarding client queries.</p>

    {{with index .Flash "upstreams"}}
        <div class="alert alert-success">{{.}}</div>
    {{end}}
    {{with index .Errors "upstreams"}}
        <div class="alert alert-danger">{{.}}</div>
    {{end}}

    <form hx-put="/api/config/upstreams" hx-target="#upstreams-section" hx-swap="outerHTML">
        <div class="form-group">
            <label for="servers">Resolvers</label>
            <textarea id="servers" name="servers" rows="4" spellcheck="false" data-validate="dns-server" aria-describedby="servers-help">{{join $cfg.UpstreamDNSServers "\n"}}</textarea>
            <span id="servers-help" class="form-help">One host:port per line (e.g., <code>1.1.1.1:53</code>, <code>[2606:4700:4700::1111]:53</code>).</span>
        </div>
        <div class="form-actions">
            <button type="reset" class="btn btn-secondary btn-sm">Reset</button>
            <button type="submit" class="btn btn-primary btn-sm">Save Upstreams</button>
        </div>
    </form>
</div>
{{end}}

{{define "settings-cache"}}
{{$cfg := .Config}}
<div class="settings-section" id="cache-section">
    <h3>Cache Configuration</h3>
    <p class="section-description">Tune TTL bounds and capacity for the in-memory DNS cache.</p>

    {{with index .Flash "cache"}}
        <div class="alert alert-success">{{.}}</div>
    {{end}}
    {{with index .Errors "cache"}}
        <div class="alert alert-danger">{{.}}</div>
    {{end}}

    <form hx-put="/api/config/cache" hx-target="#cache-section" hx-swap="outerHTML">
        <label class="checkbox-label" for="cache-enabled">
            <input id="cache-enabled" type="checkbox" name="enabled" {{if $cfg.Cache.Enabled}}checked{{end}}>
            Enable DNS response cache
        </label>

        <div class="form-group">
            <label for="cache-max-entries">Maximum Entries</label>
            <input id="cache-max-entries" type="number" min="1" name="max_entries" value="{{$cfg.Cache.MaxEntries}}">
            <span class="form-help">Total cached responses retained before eviction.</span>
        </div>

        <div class="form-grid">
            <div class="form-group">
                <label for="cache-min-ttl">Minimum TTL</label>
                <input id="cache-min-ttl" type="text" name="min_ttl" value="{{$cfg.Cache.MinTTL}}" placeholder="e.g., 30s, 5m" data-validate="duration" aria-describedby="cache-min-ttl-help">
                <span id="cache-min-ttl-help" class="form-help">Go-style duration string.</span>
            </div>
            <div class="form-group">
                <label for="cache-max-ttl">Maximum TTL</label>
                <input id="cache-max-ttl" type="text" name="max_ttl" value="{{$cfg.Cache.MaxTTL}}" placeholder="e.g., 12h" data-validate="duration">
            </div>
        </div>

        <div class="form-grid">
            <div class="form-group">
                <label for="cache-negative-ttl">Negative TTL</label>
                <input id="cache-negative-ttl" type="text" name="negative_ttl" value="{{$cfg.Cache.NegativeTTL}}">
                <span class="form-help">How long NXDOMAIN responses are cached.</span>
            </div>
            <div class="form-group">
                <label for="cache-blocked-ttl">Blocked TTL</label>
                <input id="cache-blocked-ttl" type="text" name="blocked_ttl" value="{{$cfg.Cache.BlockedTTL}}">
            </div>
        </div>

        <div class="form-group">
            <label for="cache-shards">Shard Count</label>
            <input id="cache-shards" type="number" min="0" name="shard_count" value="{{$cfg.Cache.ShardCount}}">
            <span class="form-help">0 lets Gloryhole auto-size shards based on CPU cores.</span>
        </div>

        <div class="form-actions">
            <button type="reset" class="btn btn-secondary btn-sm">Reset</button>
            <button type="submit" class="btn btn-primary btn-sm">Save Cache Settings</button>
        </div>
    </form>
</div>
{{end}}

{{define "settings-logging"}}
{{$cfg := .Config}}
<div class="settings-section" id="logging-section">
    <h3>Logging Configuration</h3>
    <p class="section-description">Control log verbosity, format, output target, and retention.</p>

    {{with index .Flash "logging"}}
        <div class="alert alert-success">{{.}}</div>
    {{end}}
    {{with index .Errors "logging"}}
        <div class="alert alert-danger">{{.}}</div>
    {{end}}

    <form hx-put="/api/config/logging" hx-target="#logging-section" hx-swap="outerHTML">
        <div class="form-grid">
            <div class="form-group">
                <label for="logging-level">Log Level</label>
                <select id="logging-level" name="level">
                    <option value="debug" {{if eq (lower $cfg.Logging.Level) "debug"}}selected{{end}}>Debug</option>
                    <option value="info" {{if eq (lower $cfg.Logging.Level) "info"}}selected{{end}}>Info</option>
                    <option value="warn" {{if eq (lower $cfg.Logging.Level) "warn"}}selected{{end}}>Warn</option>
                    <option value="error" {{if eq (lower $cfg.Logging.Level) "error"}}selected{{end}}>Error</option>
                </select>
            </div>
            <div class="form-group">
                <label for="logging-format">Format</label>
                <select id="logging-format" name="format">
                    <option value="text" {{if eq (lower $cfg.Logging.Format) "text"}}selected{{end}}>Text</option>
                    <option value="json" {{if eq (lower $cfg.Logging.Format) "json"}}selected{{end}}>JSON</option>
                </select>
            </div>
            <div class="form-group">
                <label for="logging-output">Output</label>
                <select id="logging-output" name="output">
                    <option value="stdout" {{if eq (lower $cfg.Logging.Output) "stdout"}}selected{{end}}>stdout</option>
                    <option value="stderr" {{if eq (lower $cfg.Logging.Output) "stderr"}}selected{{end}}>stderr</option>
                    <option value="file" {{if eq (lower $cfg.Logging.Output) "file"}}selected{{end}}>File</option>
                </select>
            </div>
        </div>

        <div class="form-group">
            <label for="logging-file">File Path</label>
            <input id="logging-file" type="text" name="file_path" value="{{$cfg.Logging.FilePath}}" placeholder="/var/log/glory-hole.log">
            <span class="form-help">Required when output is <code>file</code>.</span>
        </div>

        <label class="checkbox-label" for="logging-add-source">
            <input id="logging-add-source" type="checkbox" name="add_source" {{if $cfg.Logging.AddSource}}checked{{end}}>
            Include source file/line (adds ~1-2Âµs per log)
        </label>

        <div class="form-grid">
            <div class="form-group">
                <label for="logging-max-size">Max Size (MB)</label>
                <input id="logging-max-size" type="number" min="1" name="max_size" value="{{$cfg.Logging.MaxSize}}">
            </div>
            <div class="form-group">
                <label for="logging-max-backups">Max Backups</label>
                <input id="logging-max-backups" type="number" min="0" name="max_backups" value="{{$cfg.Logging.MaxBackups}}">
            </div>
            <div class="form-group">
                <label for="logging-max-age">Max Age (days)</label>
                <input id="logging-max-age" type="number" min="0" name="max_age" value="{{$cfg.Logging.MaxAge}}">
            </div>
        </div>

        <div class="form-actions">
            <button type="reset" class="btn btn-secondary btn-sm">Reset</button>
            <button type="submit" class="btn btn-primary btn-sm">Save Logging Settings</button>
        </div>
    </form>
</div>
{{end}}

{{define "settings-rate-limit"}}
{{$cfg := .Config}}
<div class="settings-section" id="rate-limit-section">
    <h3>Rate Limiting</h3>
    <p class="section-description">Global per-client token bucket before policy/blocklist evaluation.</p>

    {{with index .Flash "rate_limit"}}
        <div class="alert alert-success">{{.}}</div>
    {{end}}
    {{with index .Errors "rate_limit"}}
        <div class="alert alert-danger">{{.}}</div>
    {{end}}

    <form hx-put="/api/config/rate-limit" hx-target="#rate-limit-section" hx-swap="outerHTML">
        <label class="checkbox-label" for="rl-enabled">
            <input id="rl-enabled" type="checkbox" name="enabled" {{if $cfg.RateLimit.Enabled}}checked{{end}}>
            Enable rate limiting
        </label>

        <div class="form-grid">
            <div class="form-group">
                <label for="rl-rps">Requests per second</label>
                <input id="rl-rps" type="number" min="1" step="1" name="requests_per_second" value="{{$cfg.RateLimit.RequestsPerSecond}}">
            </div>
            <div class="form-group">
                <label for="rl-burst">Burst</label>
                <input id="rl-burst" type="number" min="1" step="1" name="burst" value="{{$cfg.RateLimit.Burst}}">
            </div>
        </div>

        <div class="form-group">
            <label for="rl-action">On exceed</label>
            <select id="rl-action" name="on_exceed">
                <option value="nxdomain" {{if eq $cfg.RateLimit.Action "nxdomain"}}selected{{end}}>NXDOMAIN</option>
                <option value="drop" {{if eq $cfg.RateLimit.Action "drop"}}selected{{end}}>Drop</option>
            </select>
        </div>

        <div class="form-grid">
            <div class="form-group">
                <label for="rl-cleanup">Cleanup interval</label>
                <input id="rl-cleanup" type="text" name="cleanup_interval" value="{{$cfg.RateLimit.CleanupInterval}}" placeholder="e.g., 10m">
            </div>
            <div class="form-group">
                <label for="rl-max-tracked">Max tracked clients</label>
                <input id="rl-max-tracked" type="number" min="1" step="1" name="max_tracked_clients" value="{{$cfg.RateLimit.MaxTrackedClients}}">
            </div>
        </div>

        <label class="checkbox-label" for="rl-log">
            <input id="rl-log" type="checkbox" name="log_violations" {{if $cfg.RateLimit.LogViolations}}checked{{end}}>
            Log violations
        </label>

        <p class="form-help">Overrides ({{len $cfg.RateLimit.Overrides}}) and trusted proxies remain unchanged; edit in config.yml if needed.</p>

        <div class="form-actions">
            <button type="reset" class="btn btn-secondary btn-sm">Reset</button>
            <button type="submit" class="btn btn-primary btn-sm">Save Rate Limit</button>
        </div>
    </form>
</div>
{{end}}

{{define "settings-tls"}}
{{$cfg := .Config}}
<div class="settings-section" id="tls-section">
    <h3>DNS-over-TLS (DoT) & TLS</h3>
    <p class="section-description">Control DoT listener and certificate source.</p>

    {{with index .Flash "tls"}}
        <div class="alert alert-success">{{.}}</div>
    {{end}}
    {{with index .Errors "tls"}}
        <div class="alert alert-danger">{{.}}</div>
    {{end}}

    <form hx-put="/api/config/tls" hx-target="#tls-section" hx-swap="outerHTML">
        <label class="checkbox-label" for="dot-enabled">
            <input id="dot-enabled" type="checkbox" name="dot_enabled" {{if $cfg.Server.DotEnabled}}checked{{end}}>
            Enable DNS-over-TLS listener
        </label>

        <div class="form-group">
            <label for="dot-address">DoT address</label>
            <input id="dot-address" type="text" name="dot_address" value="{{$cfg.Server.DotAddress}}" placeholder=":853">
        </div>

        <div class="form-group">
            <label>Manual certificates (PEM paths)</label>
            <div class="form-grid">
                <input type="text" name="cert_file" placeholder="/path/to/fullchain.pem" value="{{$cfg.Server.TLS.CertFile}}">
                <input type="text" name="key_file" placeholder="/path/to/privkey.pem" value="{{$cfg.Server.TLS.KeyFile}}">
            </div>
        </div>

        <div class="fieldset">
            <h4>Autocert (HTTP-01)</h4>
            <label class="checkbox-label" for="ac-enabled">
                <input id="ac-enabled" type="checkbox" name="autocert_enabled" {{if $cfg.Server.TLS.Autocert.Enabled}}checked{{end}}>
                Enable autocert
            </label>
            <div class="form-group">
                <label for="ac-hosts">Hosts (comma/line separated)</label>
                <textarea id="ac-hosts" name="autocert_hosts" rows="2">{{join $cfg.Server.TLS.Autocert.Hosts "\n"}}</textarea>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label for="ac-cache">Cache dir</label>
                    <input id="ac-cache" type="text" name="autocert_cache_dir" value="{{$cfg.Server.TLS.Autocert.CacheDir}}">
                </div>
                <div class="form-group">
                    <label for="ac-email">Email</label>
                    <input id="ac-email" class="filter-input" type="email" name="autocert_email" value="{{$cfg.Server.TLS.Autocert.Email}}" placeholder="you@example.com" data-validate="email">
                </div>
            </div>
            <div class="form-group">
                <label for="ac-http01">HTTP-01 address</label>
                <input id="ac-http01" type="text" name="autocert_http01_address" value="{{$cfg.Server.TLS.Autocert.HTTP01Address}}">
            </div>
        </div>

        <div class="fieldset">
            <h4>Native ACME (DNS-01)</h4>
            <label class="checkbox-label" for="acme-enabled">
                <input id="acme-enabled" type="checkbox" name="acme_enabled" {{if $cfg.Server.TLS.ACME.Enabled}}checked{{end}}>
                Enable ACME DNS-01
            </label>
            <div class="form-group">
                <label for="acme-hosts">Hosts (comma/line separated)</label>
                <textarea id="acme-hosts" name="acme_hosts" rows="2">{{join $cfg.Server.TLS.ACME.Hosts "\n"}}</textarea>
            </div>
            <div class="form-group">
                <label for="acme-upstreams">ACME upstream DNS (comma/line separated)</label>
                <textarea id="acme-upstreams" name="acme_upstreams" rows="2">{{join $cfg.Server.TLS.ACME.Upstreams "\n"}}</textarea>
                <span class="form-help">Overrides global upstreams for ACME/Cloudflare lookups; leave empty to inherit.</span>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label for="acme-cache">Cache dir</label>
                    <input id="acme-cache" type="text" name="acme_cache_dir" value="{{$cfg.Server.TLS.ACME.CacheDir}}">
                </div>
                <div class="form-group">
                    <label for="acme-email">Email</label>
                    <input id="acme-email" class="filter-input" type="email" name="acme_email" value="{{$cfg.Server.TLS.ACME.Email}}" placeholder="you@example.com" data-validate="email">
                </div>
            </div>
            <div class="form-group">
                <label for="acme-renew-before">Renew before</label>
                <input id="acme-renew-before" type="text" name="acme_renew_before" value="{{$cfg.Server.TLS.ACME.RenewBefore}}" placeholder="720h">
                <span class="form-help">Go duration, e.g., 720h (30d).</span>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label for="acme-cf-zone">Cloudflare Zone ID (optional)</label>
                    <input id="acme-cf-zone" type="text" name="acme_cf_zone_id" value="{{$cfg.Server.TLS.ACME.Cloudflare.ZoneID}}" placeholder="d6260a9cd0c27db1e9c0a453b2e4761e">
                    <span class="form-help">Skips zone discovery and speeds issuance.</span>
                </div>
                <div class="form-group">
                    <label for="acme-cf-ttl">CF TXT TTL (>=120)</label>
                    <input id="acme-cf-ttl" type="number" min="120" name="acme_cf_ttl" value="{{$cfg.Server.TLS.ACME.Cloudflare.TTL}}">
                </div>
            </div>
            <div class="form-grid">
                <div class="form-group">
                    <label for="acme-cf-prop">Propagation timeout</label>
                    <input id="acme-cf-prop" type="text" name="acme_cf_propagation_timeout" value="{{$cfg.Server.TLS.ACME.Cloudflare.PropagationTimeout}}" placeholder="2m">
                </div>
                <div class="form-group">
                    <label for="acme-cf-poll">Polling interval</label>
                    <input id="acme-cf-poll" type="text" name="acme_cf_polling_interval" value="{{$cfg.Server.TLS.ACME.Cloudflare.PollingInterval}}" placeholder="2s">
                </div>
            </div>
            <label class="checkbox-label" for="acme-cf-skip-auth">
                <input id="acme-cf-skip-auth" type="checkbox" name="acme_cf_skip_auth_check" {{if $cfg.Server.TLS.ACME.Cloudflare.SkipAuthNSCheck}}checked{{end}}>
                Skip authoritative NS propagation check (use recursive only)
            </label>
            <input type="hidden" name="acme_dns_provider" value="{{$cfg.Server.TLS.ACME.DNSProvider}}">
        </div>

        <div class="form-actions">
            <button type="reset" class="btn btn-secondary btn-sm">Reset</button>
            <button type="submit" class="btn btn-primary btn-sm">Save DoT/TLS</button>
        </div>
        <p class="form-help">API tokens are read from environment (e.g., CF_DNS_API_TOKEN); they are not shown here.</p>
    </form>
</div>
{{end}}

{{define "content"}}
{{$cfg := .Config}}
<div class="settings-page">
    <div class="page-header">
        <h2>Settings</h2>
        <p class="section-description">Active configuration file: <code>{{if .ConfigPath}}{{.ConfigPath}}{{else}}config.yml{{end}}</code></p>
    </div>

    <div class="settings-section">
        <h3>DNS Listener</h3>
        <div class="setting-row">
            <div class="setting-label">
                <h4>DNS Listen Address</h4>
                <p>UDP and TCP DNS server bind address</p>
            </div>
            <div class="setting-value">
                <code>{{$cfg.Server.ListenAddress}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Protocols</h4>
                <p>Enabled transport protocols</p>
            </div>
            <div class="setting-value">
                <code>{{if $cfg.Server.UDPEnabled}}UDP{{end}}{{if and $cfg.Server.UDPEnabled $cfg.Server.TCPEnabled}}, {{end}}{{if $cfg.Server.TCPEnabled}}TCP{{end}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Decision Trace</h4>
                <p>Capture block breadcrumbs for UI/API troubleshooting</p>
            </div>
            <div class="setting-value">
                <label class="toggle-switch">
                    <input type="checkbox" {{if $cfg.Server.DecisionTrace}}checked{{end}} disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
    </div>

    {{template "settings-tls" .}}

    {{template "settings-upstreams" .}}

    {{template "settings-cache" .}}

    <!-- Blocklist Settings -->
    <div class="settings-section">
        <h3>Blocklist Configuration</h3>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Auto-Update</h4>
                <p>Automatically update blocklists</p>
            </div>
            <div class="setting-value">
                <label class="toggle-switch">
                    <input type="checkbox" {{if $cfg.AutoUpdateBlocklists}}checked{{end}} disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Update Interval</h4>
                <p>How often to refresh blocklists</p>
            </div>
            <div class="setting-value">
                <code>{{$cfg.UpdateInterval}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Blocklist Sources</h4>
                <p>Active blocklist URLs</p>
            </div>
            <div class="setting-value">
                <button class="btn btn-secondary btn-sm">View Sources ({{len $cfg.Blocklists}})</button>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Manual Reload</h4>
                <p>Force reload all blocklists now</p>
            </div>
            <div class="setting-value">
                <button class="btn btn-primary btn-sm" onclick="reloadBlocklists()">Reload Now</button>
            </div>
        </div>
    </div>

    <!-- Feature Controls (Kill-Switches) -->
    <div class="settings-section">
        <h3>Feature Controls</h3>
        <p class="section-description">Temporarily disable features for troubleshooting or maintenance.</p>

        <div class="feature-control-group">
            <div class="feature-header">
                <h4>Ad-Blocking (Blocklist)</h4>
                <span id="blocklist-status" class="status-badge">{{if $cfg.Server.EnableBlocklist}}Enabled{{else}}Disabled{{end}}</span>
            </div>
            <p class="help-text">Temporarily disable domain blocking for troubleshooting false positives.</p>

            <div class="control-buttons">
                <button class="btn btn-danger btn-sm" onclick="disableFeature('blocklist', 30)">30 seconds</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('blocklist', 300)">5 minutes</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('blocklist', 1800)">30 minutes</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('blocklist', 3600)">1 hour</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('blocklist', 0)">Indefinitely</button>
                <button class="btn btn-success btn-sm" onclick="enableFeature('blocklist')">Re-enable</button>
            </div>

            <div id="blocklist-countdown" class="countdown-timer" style="display: none;">
                Will auto-re-enable in: <span id="blocklist-time">--</span>
            </div>
        </div>

        <div class="feature-control-group">
            <div class="feature-header">
                <h4>Policy Engine</h4>
                <span id="policies-status" class="status-badge">{{if $cfg.Server.EnablePolicies}}Enabled{{else}}Disabled{{end}}</span>
            </div>
            <p class="help-text">Temporarily disable all policy rules while keeping basic blocklist active.</p>

            <div class="control-buttons">
                <button class="btn btn-danger btn-sm" onclick="disableFeature('policies', 30)">30 seconds</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('policies', 300)">5 minutes</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('policies', 1800)">30 minutes</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('policies', 3600)">1 hour</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('policies', 0)">Indefinitely</button>
                <button class="btn btn-success btn-sm" onclick="enableFeature('policies')">Re-enable</button>
            </div>

            <div id="policies-countdown" class="countdown-timer" style="display: none;">
                Will auto-re-enable in: <span id="policies-time">--</span>
            </div>
        </div>
    </div>

    <!-- Storage Settings -->
    <div class="settings-section">
        <h3>Storage Configuration</h3>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Backend</h4>
                <p>Query log storage backend</p>
            </div>
            <div class="setting-value">
                <code>{{$cfg.Storage.Backend}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Buffer Size</h4>
                <p>Queries buffered before write</p>
            </div>
            <div class="setting-value">
                <code>{{$cfg.Storage.BufferSize}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Retention Period</h4>
                <p>How long to keep query logs</p>
            </div>
            <div class="setting-value">
                <code>{{$cfg.Storage.RetentionDays}} days</code>
            </div>
        </div>
    </div>

    {{template "settings-rate-limit" .}}

    <!-- Danger Zone -->
    <div class="settings-section danger-zone">
        <h3>Danger Zone</h3>
        <p class="section-description">Permanently delete all stored query logs, statistics, and client metadata. This cannot be undone.</p>
        <div class="form-group">
            <label for="storage-nuke-confirm">Type <code>NUKE</code> to confirm</label>
            <input id="storage-nuke-confirm" type="text" placeholder="NUKE">
        </div>
        <div class="form-actions">
            <button id="storage-nuke-btn" class="btn btn-danger btn-sm" type="button" onclick="resetStorage()">Delete All Query Data</button>
        </div>
    </div>

    <!-- Logging Settings -->
    {{template "settings-logging" .}}

    <!-- API Settings -->
    <div class="settings-section">
        <h3>API Server</h3>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Listen Address</h4>
                <p>HTTP API and Web UI address</p>
            </div>
            <div class="setting-value">
                <code>{{$cfg.Server.WebUIAddress}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>CORS Enabled</h4>
                <p>Allow cross-origin requests</p>
            </div>
            <div class="setting-value">
                {{if $cfg.Server.CORSAllowedOrigins}}
                    <code>{{join ", " $cfg.Server.CORSAllowedOrigins}}</code>
                {{else}}
                    <code>Disabled (no allowed origins)</code>
                {{end}}
            </div>
        </div>
    </div>

    <!-- Telemetry Settings -->
    <div class="settings-section">
        <h3>Telemetry & Monitoring</h3>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Prometheus Metrics</h4>
                <p>Enable Prometheus endpoint</p>
            </div>
            <div class="setting-value">
                <label class="toggle-switch">
                    <input type="checkbox" {{if $cfg.Telemetry.PrometheusEnabled}}checked{{end}} disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Metrics Port</h4>
                <p>Prometheus endpoint port</p>
            </div>
            <div class="setting-value">
                <code>{{if gt $cfg.Telemetry.PrometheusPort 0}}:{{$cfg.Telemetry.PrometheusPort}}{{else}}Disabled{{end}}</code>
            </div>
        </div>
    </div>

    <!-- System Info -->
    <div class="settings-section">
        <h3>System Information</h3>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Version</h4>
                <p>Gloryhole version</p>
            </div>
            <div class="setting-value">
                <code>{{.Version}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Configuration File</h4>
                <p>Active configuration file path</p>
            </div>
            <div class="setting-value">
                <code>{{if .ConfigPath}}{{.ConfigPath}}{{else}}config.yml{{end}}</code>
            </div>
        </div>
    </div>

    <div class="settings-info">
        <p><strong>Tip:</strong> Upstreams, cache, and logging settings can be edited live above. Other sections remain read-only and require editing <code>config.yml</code> followed by a restart.</p>
        <p>Use the Policies page for runtime policy updates.</p>
    </div>
</div>

<script>
async function resetStorage() {
    const input = document.getElementById('storage-nuke-confirm');
    const button = document.getElementById('storage-nuke-btn');
    if (!input || !button) {
        return;
    }

    const value = (input.value || '').trim().toUpperCase();
    if (value !== 'NUKE') {
        alert('Please type "NUKE" to confirm.');
        input.focus();
        return;
    }

    if (!confirm('This will permanently delete all stored query data. Continue?')) {
        return;
    }

    const defaultLabel = button.textContent;
    button.disabled = true;
    button.textContent = 'Deleting...';

    try {
        const response = await fetch('/api/storage/reset', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ confirm: 'NUKE' })
        });

        if (!response.ok) {
            let errorMessage = 'Failed to reset storage';
            try {
                const error = await response.json();
                errorMessage = error.message || errorMessage;
            } catch (_) {
                // ignore JSON parse errors
            }
            throw new Error(errorMessage);
        }

        input.value = '';
        alert('All stored query data has been deleted.');
    } catch (error) {
        alert('Error: ' + error.message);
    } finally {
        button.disabled = false;
        button.textContent = defaultLabel;
    }
}

async function reloadBlocklists() {
    const button = event.target;
    button.disabled = true;
    button.textContent = 'Reloading...';

    try {
        const response = await fetch('/api/blocklist/reload', {
            method: 'POST'
        });

        if (response.ok) {
            const result = await response.json();
            alert(`Blocklists reloaded successfully!\n${result.domains} domains loaded.`);
        } else {
            const error = await response.json();
            alert('Error: ' + (error.message || 'Failed to reload blocklists'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    } finally {
        button.disabled = false;
        button.textContent = 'Reload Now';
    }
}

let blocklistCountdownInterval = null;
let policiesCountdownInterval = null;

async function disableFeature(feature, duration) {
    const featureName = feature === 'blocklist' ? 'Blocklist' : 'Policies';
    const durationText = duration === 0 ? 'indefinitely' : formatDuration(duration);

    if (!confirm(`Disable ${featureName} ${durationText}?`)) {
        return;
    }

    try {
        const response = await fetch(`/api/features/${feature}/disable`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ duration: duration })
        });

        if (response.ok) {
            await response.json();
            updateFeatureStatus();
        } else {
            const error = await response.json();
            alert('Error: ' + (error.message || `Failed to disable ${featureName}`));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function enableFeature(feature) {
    const featureName = feature === 'blocklist' ? 'Blocklist' : 'Policies';

    try {
        const response = await fetch(`/api/features/${feature}/enable`, {
            method: 'POST'
        });

        if (response.ok) {
            await response.json();
            updateFeatureStatus();
        } else {
            const error = await response.json();
            alert('Error: ' + (error.message || `Failed to enable ${featureName}`));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function updateFeatureStatus() {
    try {
        const response = await fetch('/api/features');
        if (!response.ok) {
            throw new Error('Failed to fetch feature status');
        }

        const data = await response.json();
        const blocklistStatus = document.getElementById('blocklist-status');
        const policiesStatus = document.getElementById('policies-status');

        blocklistStatus.textContent = data.blocklist_enabled ? 'Enabled' : 'Disabled';
        blocklistStatus.className = `status-badge ${data.blocklist_enabled ? 'success' : 'danger'}`;

        policiesStatus.textContent = data.policies_enabled ? 'Enabled' : 'Disabled';
        policiesStatus.className = `status-badge ${data.policies_enabled ? 'success' : 'danger'}`;

        updateCountdown('blocklist', data.blocklist_temp_disabled, data.blocklist_disabled_until);
        updateCountdown('policies', data.policies_temp_disabled, data.policies_disabled_until);
    } catch (error) {
        console.error('Failed to update feature status:', error);
    }
}

function formatDuration(seconds) {
    if (seconds < 60) return `${seconds}s`;
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
    return `${Math.floor(seconds / 3600)}h`;
}

function updateCountdown(feature, isDisabled, until) {
    const countdownElement = document.getElementById(`${feature}-countdown`);
    const timeElement = document.getElementById(`${feature}-time`);
    let intervalRef = feature === 'blocklist' ? blocklistCountdownInterval : policiesCountdownInterval;

    if (intervalRef) {
        clearInterval(intervalRef);
    }

    if (!isDisabled || !until) {
        countdownElement.style.display = 'none';
        return;
    }

    countdownElement.style.display = 'block';

    function updateTimer() {
        const remainingSeconds = Math.max(0, Math.floor((new Date(until) - new Date()) / 1000));
        const minutes = Math.floor(remainingSeconds / 60);
        const seconds = remainingSeconds % 60;
        timeElement.textContent = `${minutes}m ${seconds}s`;

        if (remainingSeconds <= 0) {
            clearInterval(intervalRef);
            updateFeatureStatus();
        }
    }

    updateTimer();
    intervalRef = setInterval(updateTimer, 1000);

    if (feature === 'blocklist') {
        blocklistCountdownInterval = intervalRef;
    } else {
        policiesCountdownInterval = intervalRef;
    }
}

updateFeatureStatus();
</script>
{{end}}

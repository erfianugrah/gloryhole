{{template "base.html" .}}

{{define "title"}}Settings - Gloryhole{{end}}

{{define "settings-upstreams"}}
{{$cfg := .Config}}
<div class="settings-section" id="upstreams-section">
    <h3>Upstream DNS Servers</h3>
    <p class="section-description">Control which recursive resolvers Gloryhole uses when forwarding client queries.</p>

    {{with index .Flash "upstreams"}}
        <div class="alert alert-success">{{.}}</div>
    {{end}}
    {{with index .Errors "upstreams"}}
        <div class="alert alert-danger">{{.}}</div>
    {{end}}

    <form hx-put="/api/config/upstreams" hx-target="#upstreams-section" hx-swap="outerHTML">
        <div class="form-group">
            <label for="servers">Resolvers</label>
            <textarea id="servers" name="servers" rows="4" spellcheck="false">{{join $cfg.UpstreamDNSServers "\n"}}</textarea>
            <span class="form-help">One host:port per line (e.g., <code>1.1.1.1:53</code>, <code>[2606:4700:4700::1111]:53</code>).</span>
        </div>
        <div class="form-actions">
            <button type="reset" class="btn btn-secondary btn-sm">Reset</button>
            <button type="submit" class="btn btn-primary btn-sm">Save Upstreams</button>
        </div>
    </form>
</div>
{{end}}

{{define "settings-cache"}}
{{$cfg := .Config}}
<div class="settings-section" id="cache-section">
    <h3>Cache Configuration</h3>
    <p class="section-description">Tune TTL bounds and capacity for the in-memory DNS cache.</p>

    {{with index .Flash "cache"}}
        <div class="alert alert-success">{{.}}</div>
    {{end}}
    {{with index .Errors "cache"}}
        <div class="alert alert-danger">{{.}}</div>
    {{end}}

    <form hx-put="/api/config/cache" hx-target="#cache-section" hx-swap="outerHTML">
        <label class="checkbox-label" for="cache-enabled">
            <input id="cache-enabled" type="checkbox" name="enabled" {{if $cfg.Cache.Enabled}}checked{{end}}>
            Enable DNS response cache
        </label>

        <div class="form-group">
            <label for="cache-max-entries">Maximum Entries</label>
            <input id="cache-max-entries" type="number" min="1" name="max_entries" value="{{$cfg.Cache.MaxEntries}}">
            <span class="form-help">Total cached responses retained before eviction.</span>
        </div>

        <div class="form-grid">
            <div class="form-group">
                <label for="cache-min-ttl">Minimum TTL</label>
                <input id="cache-min-ttl" type="text" name="min_ttl" value="{{$cfg.Cache.MinTTL}}" placeholder="e.g., 30s, 5m">
                <span class="form-help">Go-style duration string.</span>
            </div>
            <div class="form-group">
                <label for="cache-max-ttl">Maximum TTL</label>
                <input id="cache-max-ttl" type="text" name="max_ttl" value="{{$cfg.Cache.MaxTTL}}" placeholder="e.g., 12h">
            </div>
        </div>

        <div class="form-grid">
            <div class="form-group">
                <label for="cache-negative-ttl">Negative TTL</label>
                <input id="cache-negative-ttl" type="text" name="negative_ttl" value="{{$cfg.Cache.NegativeTTL}}">
                <span class="form-help">How long NXDOMAIN responses are cached.</span>
            </div>
            <div class="form-group">
                <label for="cache-blocked-ttl">Blocked TTL</label>
                <input id="cache-blocked-ttl" type="text" name="blocked_ttl" value="{{$cfg.Cache.BlockedTTL}}">
            </div>
        </div>

        <div class="form-group">
            <label for="cache-shards">Shard Count</label>
            <input id="cache-shards" type="number" min="0" name="shard_count" value="{{$cfg.Cache.ShardCount}}">
            <span class="form-help">0 lets Gloryhole auto-size shards based on CPU cores.</span>
        </div>

        <div class="form-actions">
            <button type="reset" class="btn btn-secondary btn-sm">Reset</button>
            <button type="submit" class="btn btn-primary btn-sm">Save Cache Settings</button>
        </div>
    </form>
</div>
{{end}}

{{define "settings-logging"}}
{{$cfg := .Config}}
<div class="settings-section" id="logging-section">
    <h3>Logging Configuration</h3>
    <p class="section-description">Control log verbosity, format, output target, and retention.</p>

    {{with index .Flash "logging"}}
        <div class="alert alert-success">{{.}}</div>
    {{end}}
    {{with index .Errors "logging"}}
        <div class="alert alert-danger">{{.}}</div>
    {{end}}

    <form hx-put="/api/config/logging" hx-target="#logging-section" hx-swap="outerHTML">
        <div class="form-grid">
            <div class="form-group">
                <label for="logging-level">Log Level</label>
                <select id="logging-level" name="level">
                    <option value="debug" {{if eq (lower $cfg.Logging.Level) "debug"}}selected{{end}}>Debug</option>
                    <option value="info" {{if eq (lower $cfg.Logging.Level) "info"}}selected{{end}}>Info</option>
                    <option value="warn" {{if eq (lower $cfg.Logging.Level) "warn"}}selected{{end}}>Warn</option>
                    <option value="error" {{if eq (lower $cfg.Logging.Level) "error"}}selected{{end}}>Error</option>
                </select>
            </div>
            <div class="form-group">
                <label for="logging-format">Format</label>
                <select id="logging-format" name="format">
                    <option value="text" {{if eq (lower $cfg.Logging.Format) "text"}}selected{{end}}>Text</option>
                    <option value="json" {{if eq (lower $cfg.Logging.Format) "json"}}selected{{end}}>JSON</option>
                </select>
            </div>
            <div class="form-group">
                <label for="logging-output">Output</label>
                <select id="logging-output" name="output">
                    <option value="stdout" {{if eq (lower $cfg.Logging.Output) "stdout"}}selected{{end}}>stdout</option>
                    <option value="stderr" {{if eq (lower $cfg.Logging.Output) "stderr"}}selected{{end}}>stderr</option>
                    <option value="file" {{if eq (lower $cfg.Logging.Output) "file"}}selected{{end}}>File</option>
                </select>
            </div>
        </div>

        <div class="form-group">
            <label for="logging-file">File Path</label>
            <input id="logging-file" type="text" name="file_path" value="{{$cfg.Logging.FilePath}}" placeholder="/var/log/glory-hole.log">
            <span class="form-help">Required when output is <code>file</code>.</span>
        </div>

        <label class="checkbox-label" for="logging-add-source">
            <input id="logging-add-source" type="checkbox" name="add_source" {{if $cfg.Logging.AddSource}}checked{{end}}>
            Include source file/line (adds ~1-2Âµs per log)
        </label>

        <div class="form-grid">
            <div class="form-group">
                <label for="logging-max-size">Max Size (MB)</label>
                <input id="logging-max-size" type="number" min="1" name="max_size" value="{{$cfg.Logging.MaxSize}}">
            </div>
            <div class="form-group">
                <label for="logging-max-backups">Max Backups</label>
                <input id="logging-max-backups" type="number" min="0" name="max_backups" value="{{$cfg.Logging.MaxBackups}}">
            </div>
            <div class="form-group">
                <label for="logging-max-age">Max Age (days)</label>
                <input id="logging-max-age" type="number" min="0" name="max_age" value="{{$cfg.Logging.MaxAge}}">
            </div>
        </div>

        <div class="form-actions">
            <button type="reset" class="btn btn-secondary btn-sm">Reset</button>
            <button type="submit" class="btn btn-primary btn-sm">Save Logging Settings</button>
        </div>
    </form>
</div>
{{end}}

{{define "content"}}
{{$cfg := .Config}}
<div class="settings-page">
    <div class="page-header">
        <h2>Settings</h2>
        <p class="section-description">Active configuration file: <code>{{if .ConfigPath}}{{.ConfigPath}}{{else}}config.yml{{end}}</code></p>
    </div>

    <div class="settings-section">
        <h3>DNS Listener</h3>
        <div class="setting-row">
            <div class="setting-label">
                <h4>DNS Listen Address</h4>
                <p>UDP and TCP DNS server bind address</p>
            </div>
            <div class="setting-value">
                <code>{{$cfg.Server.ListenAddress}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Protocols</h4>
                <p>Enabled transport protocols</p>
            </div>
            <div class="setting-value">
                <code>{{if $cfg.Server.UDPEnabled}}UDP{{end}}{{if and $cfg.Server.UDPEnabled $cfg.Server.TCPEnabled}}, {{end}}{{if $cfg.Server.TCPEnabled}}TCP{{end}}</code>
            </div>
        </div>
    </div>

    {{template "settings-upstreams" .}}

    {{template "settings-cache" .}}

    <!-- Blocklist Settings -->
    <div class="settings-section">
        <h3>Blocklist Configuration</h3>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Auto-Update</h4>
                <p>Automatically update blocklists</p>
            </div>
            <div class="setting-value">
                <label class="toggle-switch">
                    <input type="checkbox" {{if $cfg.AutoUpdateBlocklists}}checked{{end}} disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Update Interval</h4>
                <p>How often to refresh blocklists</p>
            </div>
            <div class="setting-value">
                <code>{{$cfg.UpdateInterval}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Blocklist Sources</h4>
                <p>Active blocklist URLs</p>
            </div>
            <div class="setting-value">
                <button class="btn btn-secondary btn-sm">View Sources ({{len $cfg.Blocklists}})</button>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Manual Reload</h4>
                <p>Force reload all blocklists now</p>
            </div>
            <div class="setting-value">
                <button class="btn btn-primary btn-sm" onclick="reloadBlocklists()">Reload Now</button>
            </div>
        </div>
    </div>

    <!-- Feature Controls (Kill-Switches) -->
    <div class="settings-section">
        <h3>Feature Controls</h3>
        <p class="section-description">Temporarily disable features for troubleshooting or maintenance.</p>

        <div class="feature-control-group">
            <div class="feature-header">
                <h4>Ad-Blocking (Blocklist)</h4>
                <span id="blocklist-status" class="status-badge">{{if $cfg.Server.EnableBlocklist}}Enabled{{else}}Disabled{{end}}</span>
            </div>
            <p class="help-text">Temporarily disable domain blocking for troubleshooting false positives.</p>

            <div class="control-buttons">
                <button class="btn btn-danger btn-sm" onclick="disableFeature('blocklist', 30)">30 seconds</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('blocklist', 300)">5 minutes</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('blocklist', 1800)">30 minutes</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('blocklist', 3600)">1 hour</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('blocklist', 0)">Indefinitely</button>
                <button class="btn btn-success btn-sm" onclick="enableFeature('blocklist')">Re-enable</button>
            </div>

            <div id="blocklist-countdown" class="countdown-timer" style="display: none;">
                Will auto-re-enable in: <span id="blocklist-time">--</span>
            </div>
        </div>

        <div class="feature-control-group">
            <div class="feature-header">
                <h4>Policy Engine</h4>
                <span id="policies-status" class="status-badge">{{if $cfg.Server.EnablePolicies}}Enabled{{else}}Disabled{{end}}</span>
            </div>
            <p class="help-text">Temporarily disable all policy rules while keeping basic blocklist active.</p>

            <div class="control-buttons">
                <button class="btn btn-danger btn-sm" onclick="disableFeature('policies', 30)">30 seconds</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('policies', 300)">5 minutes</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('policies', 1800)">30 minutes</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('policies', 3600)">1 hour</button>
                <button class="btn btn-danger btn-sm" onclick="disableFeature('policies', 0)">Indefinitely</button>
                <button class="btn btn-success btn-sm" onclick="enableFeature('policies')">Re-enable</button>
            </div>

            <div id="policies-countdown" class="countdown-timer" style="display: none;">
                Will auto-re-enable in: <span id="policies-time">--</span>
            </div>
        </div>
    </div>

    <!-- Storage Settings -->
    <div class="settings-section">
        <h3>Storage Configuration</h3>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Backend</h4>
                <p>Query log storage backend</p>
            </div>
            <div class="setting-value">
                <code>{{$cfg.Storage.Backend}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Buffer Size</h4>
                <p>Queries buffered before write</p>
            </div>
            <div class="setting-value">
                <code>{{$cfg.Storage.BufferSize}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Retention Period</h4>
                <p>How long to keep query logs</p>
            </div>
            <div class="setting-value">
                <code>{{$cfg.Storage.RetentionDays}} days</code>
            </div>
        </div>
    </div>

    <!-- Danger Zone -->
    <div class="settings-section danger-zone">
        <h3>Danger Zone</h3>
        <p class="section-description">Permanently delete all stored query logs, statistics, and client metadata. This cannot be undone.</p>
        <div class="form-group">
            <label for="storage-nuke-confirm">Type <code>NUKE</code> to confirm</label>
            <input id="storage-nuke-confirm" type="text" placeholder="NUKE">
        </div>
        <div class="form-actions">
            <button id="storage-nuke-btn" class="btn btn-danger" type="button" onclick="resetStorage()">Delete All Query Data</button>
        </div>
    </div>

    <!-- Logging Settings -->
    {{template "settings-logging" .}}

    <!-- API Settings -->
    <div class="settings-section">
        <h3>API Server</h3>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Listen Address</h4>
                <p>HTTP API and Web UI address</p>
            </div>
            <div class="setting-value">
                <code>{{$cfg.Server.WebUIAddress}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>CORS Enabled</h4>
                <p>Allow cross-origin requests</p>
            </div>
            <div class="setting-value">
                <label class="toggle-switch">
                    <input type="checkbox" checked disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
    </div>

    <!-- Telemetry Settings -->
    <div class="settings-section">
        <h3>Telemetry & Monitoring</h3>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Prometheus Metrics</h4>
                <p>Enable Prometheus endpoint</p>
            </div>
            <div class="setting-value">
                <label class="toggle-switch">
                    <input type="checkbox" {{if $cfg.Telemetry.PrometheusEnabled}}checked{{end}} disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Metrics Port</h4>
                <p>Prometheus endpoint port</p>
            </div>
            <div class="setting-value">
                <code>{{if gt $cfg.Telemetry.PrometheusPort 0}}:{{$cfg.Telemetry.PrometheusPort}}{{else}}Disabled{{end}}</code>
            </div>
        </div>
    </div>

    <!-- System Info -->
    <div class="settings-section">
        <h3>System Information</h3>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Version</h4>
                <p>Gloryhole version</p>
            </div>
            <div class="setting-value">
                <code>{{.Version}}</code>
            </div>
        </div>
        <div class="setting-row">
            <div class="setting-label">
                <h4>Configuration File</h4>
                <p>Active configuration file path</p>
            </div>
            <div class="setting-value">
                <code>{{if .ConfigPath}}{{.ConfigPath}}{{else}}config.yml{{end}}</code>
            </div>
        </div>
    </div>

    <div class="settings-info">
        <p><strong>Tip:</strong> Upstreams, cache, and logging settings can be edited live above. Other sections remain read-only and require editing <code>config.yml</code> followed by a restart.</p>
        <p>Use the Policies page for runtime policy updates.</p>
    </div>
</div>

<script>
async function resetStorage() {
    const input = document.getElementById('storage-nuke-confirm');
    const button = document.getElementById('storage-nuke-btn');
    if (!input || !button) {
        return;
    }

    const value = (input.value || '').trim().toUpperCase();
    if (value !== 'NUKE') {
        alert('Please type "NUKE" to confirm.');
        input.focus();
        return;
    }

    if (!confirm('This will permanently delete all stored query data. Continue?')) {
        return;
    }

    const defaultLabel = button.textContent;
    button.disabled = true;
    button.textContent = 'Deleting...';

    try {
        const response = await fetch('/api/storage/reset', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ confirm: 'NUKE' })
        });

        if (!response.ok) {
            let errorMessage = 'Failed to reset storage';
            try {
                const error = await response.json();
                errorMessage = error.message || errorMessage;
            } catch (_) {
                // ignore JSON parse errors
            }
            throw new Error(errorMessage);
        }

        input.value = '';
        alert('All stored query data has been deleted.');
    } catch (error) {
        alert('Error: ' + error.message);
    } finally {
        button.disabled = false;
        button.textContent = defaultLabel;
    }
}

async function reloadBlocklists() {
    const button = event.target;
    button.disabled = true;
    button.textContent = 'Reloading...';

    try {
        const response = await fetch('/api/blocklist/reload', {
            method: 'POST'
        });

        if (response.ok) {
            const result = await response.json();
            alert(`Blocklists reloaded successfully!\n${result.domains} domains loaded.`);
        } else {
            const error = await response.json();
            alert('Error: ' + (error.message || 'Failed to reload blocklists'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    } finally {
        button.disabled = false;
        button.textContent = 'Reload Now';
    }
}

let blocklistCountdownInterval = null;
let policiesCountdownInterval = null;

async function disableFeature(feature, duration) {
    const featureName = feature === 'blocklist' ? 'Blocklist' : 'Policies';
    const durationText = duration === 0 ? 'indefinitely' : formatDuration(duration);

    if (!confirm(`Disable ${featureName} ${durationText}?`)) {
        return;
    }

    try {
        const response = await fetch(`/api/features/${feature}/disable`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ duration: duration })
        });

        if (response.ok) {
            await response.json();
            updateFeatureStatus();
        } else {
            const error = await response.json();
            alert('Error: ' + (error.message || `Failed to disable ${featureName}`));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function enableFeature(feature) {
    const featureName = feature === 'blocklist' ? 'Blocklist' : 'Policies';

    try {
        const response = await fetch(`/api/features/${feature}/enable`, {
            method: 'POST'
        });

        if (response.ok) {
            await response.json();
            updateFeatureStatus();
        } else {
            const error = await response.json();
            alert('Error: ' + (error.message || `Failed to enable ${featureName}`));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function updateFeatureStatus() {
    try {
        const response = await fetch('/api/features');
        if (!response.ok) {
            throw new Error('Failed to fetch feature status');
        }

        const data = await response.json();
        const blocklistStatus = document.getElementById('blocklist-status');
        const policiesStatus = document.getElementById('policies-status');

        blocklistStatus.textContent = data.blocklist_enabled ? 'Enabled' : 'Disabled';
        blocklistStatus.className = `status-badge ${data.blocklist_enabled ? 'success' : 'danger'}`;

        policiesStatus.textContent = data.policies_enabled ? 'Enabled' : 'Disabled';
        policiesStatus.className = `status-badge ${data.policies_enabled ? 'success' : 'danger'}`;

        updateCountdown('blocklist', data.blocklist_temp_disabled, data.blocklist_disabled_until);
        updateCountdown('policies', data.policies_temp_disabled, data.policies_disabled_until);
    } catch (error) {
        console.error('Failed to update feature status:', error);
    }
}

function formatDuration(seconds) {
    if (seconds < 60) return `${seconds}s`;
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
    return `${Math.floor(seconds / 3600)}h`;
}

function updateCountdown(feature, isDisabled, until) {
    const countdownElement = document.getElementById(`${feature}-countdown`);
    const timeElement = document.getElementById(`${feature}-time`);
    let intervalRef = feature === 'blocklist' ? blocklistCountdownInterval : policiesCountdownInterval;

    if (intervalRef) {
        clearInterval(intervalRef);
    }

    if (!isDisabled || !until) {
        countdownElement.style.display = 'none';
        return;
    }

    countdownElement.style.display = 'block';

    function updateTimer() {
        const remainingSeconds = Math.max(0, Math.floor((new Date(until) - new Date()) / 1000));
        const minutes = Math.floor(remainingSeconds / 60);
        const seconds = remainingSeconds % 60;
        timeElement.textContent = `${minutes}m ${seconds}s`;

        if (remainingSeconds <= 0) {
            clearInterval(intervalRef);
            updateFeatureStatus();
        }
    }

    updateTimer();
    intervalRef = setInterval(updateTimer, 1000);

    if (feature === 'blocklist') {
        blocklistCountdownInterval = intervalRef;
    } else {
        policiesCountdownInterval = intervalRef;
    }
}

updateFeatureStatus();
</script>
{{end}}

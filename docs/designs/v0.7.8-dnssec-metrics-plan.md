# v0.7.8 - DNSSEC and Response Code Tracking

**Status**: Planned
**Target Release**: v0.7.8
**Date Created**: 2025-11-23
**Priority**: High (affects DNSSEC validation correctness)

---

## Problem Statement

### Issue 1: SERVFAIL Retry Bug (Critical)

**Current Behavior:**
When an upstream DNS server returns SERVFAIL (e.g., for DNSSEC validation failures), Glory-Hole treats it as an error and retries with the next upstream server.

```go
// pkg/forwarder/forwarder.go:113-120
if resp.Rcode == dns.RcodeServerFailure {
    f.logger.Warn("Upstream returned SERVFAIL", ...)
    lastErr = fmt.Errorf("upstream %s returned SERVFAIL", upstream)
    continue  // â† BUG: Retries next upstream!
}
```

**Why This is Wrong:**
- SERVFAIL for DNSSEC failures should be passed through immediately
- Next upstream might not validate DNSSEC â†’ returns insecure response
- Breaks DNSSEC security model
- Adds unnecessary latency (retries)

**Test Case:**
```bash
# Domain with broken DNSSEC: sigfail.ippacket.stream
dig @10.0.10.10 sigfail.ippacket.stream +dnssec

# Expected: SERVFAIL immediately (DNSSEC failure)
# Actual: SERVFAIL after retrying all upstreams
```

### Issue 2: No Response Code Metrics

**Missing Metrics:**
We track:
- âœ… `dns_queries_total` - Total queries
- âœ… `dns_queries_blocked_total` - Blocked queries
- âœ… `dns_queries_forwarded_total` - Forwarded queries

We DON'T track:
- âŒ `dns_response_code_total{code="SERVFAIL"}`
- âŒ `dns_response_code_total{code="NXDOMAIN"}`
- âŒ `dns_response_code_total{code="NOERROR"}`
- âŒ `dns_response_code_total{code="FORMERR"}`
- âŒ `dns_response_code_total{code="REFUSED"}`

**Impact:**
- Can't monitor DNSSEC failures in Grafana
- Can't alert on high SERVFAIL rates
- No visibility into DNS response patterns
- Troubleshooting is difficult

### Issue 3: Query Logging Doesn't Capture Response Codes

**Current Logging:**
```json
{
  "domain": "sigfail.ippacket.stream",
  "client_ip": "10.0.10.1",
  "query_type": "A",
  "blocked": false,
  "cached": false,
  "response_time_ms": 2000
  // Missing: "response_code": "SERVFAIL"
}
```

**Web UI Impact:**
- Query log doesn't show SERVFAIL responses
- Can't filter by response code
- Users can't see DNSSEC failures in UI

---

## Solution Design

### 1. Fix SERVFAIL Retry Logic

**Decision:** Only retry on network errors. Pass through ALL DNS responses unchanged.

**Key Principle:** We're a DNS proxy, not a validator. Return what upstream returns.

**Retry on** (network errors):
- Timeout
- Connection refused
- Network unreachable
- Nil response

**Pass through immediately** (valid DNS responses):
- NOERROR (success)
- NXDOMAIN (domain doesn't exist)
- SERVFAIL (upstream can't answer - DNSSEC, policy, etc.)
- REFUSED (upstream refuses to answer)
- FORMERR (malformed query)
- Any other response code

**Implementation:**

```go
// pkg/forwarder/forwarder.go

func (f *Forwarder) Forward(ctx context.Context, r *dns.Msg) (*dns.Msg, error) {
    // ... selection logic ...

    resp, rtt, err := client.ExchangeContext(ctx, r, upstream)

    // Network errors: retry with next upstream
    if err != nil {
        f.logger.Warn("Upstream query failed", "error", err)
        lastErr = err
        continue
    }

    // Nil response: retry with next upstream
    if resp == nil {
        lastErr = fmt.Errorf("nil response from %s", upstream)
        continue
    }

    // ANY valid DNS response: pass through immediately
    // Don't treat SERVFAIL/NXDOMAIN/etc as errors - they're valid responses!
    f.logger.Debug("Upstream query succeeded",
        "upstream", upstream,
        "domain", r.Question[0].Name,
        "rcode", dns.RcodeToString[resp.Rcode],
        "rtt", rtt,
        "answers", len(resp.Answer),
    )

    return resp, nil  // â† Return immediately for ANY response code
}
```

**Removed Code:**
```go
// OLD CODE (WRONG):
if resp.Rcode == dns.RcodeServerFailure {
    lastErr = fmt.Errorf("upstream %s returned SERVFAIL", upstream)
    continue  // â† This was the bug!
}
```

**Benefits:**
- âœ… DNSSEC failures passed through correctly
- âœ… No retry on legitimate SERVFAIL
- âœ… Lower latency (no unnecessary retries)
- âœ… Preserves DNS security model

**Breaking Change?** No - improves correctness

### 2. Add Response Code Metrics

**New Metric:**
```go
// pkg/telemetry/telemetry.go

type Metrics struct {
    // ... existing metrics ...

    // DNS response codes
    DNSResponseCodeTotal metric.Int64Counter
}

func New(cfg *config.Config, logger *logging.Logger) (*Metrics, error) {
    // ... existing setup ...

    responseCodeCounter, err := meter.Int64Counter(
        "dns_response_code_total",
        metric.WithDescription("DNS queries by response code"),
        metric.WithUnit("{query}"),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create response code counter: %w", err)
    }

    return &Metrics{
        // ... existing ...
        DNSResponseCodeTotal: responseCodeCounter,
    }, nil
}
```

**Recording Response Codes:**
```go
// pkg/dns/server_impl.go

func (w *wrappedHandler) serveDNS(rw dns.ResponseWriter, r *dns.Msg) {
    // ... existing setup ...

    // Wrap response writer to capture response code
    wrappedRW := &responseCapturingWriter{
        ResponseWriter: rw,
        msg:            nil,
    }

    // Call handler
    w.handler.ServeDNS(ctx, wrappedRW, r)

    // Record response code metric
    if w.metrics != nil && wrappedRW.msg != nil {
        rcode := dns.RcodeToString[wrappedRW.msg.Rcode]
        w.metrics.DNSResponseCodeTotal.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("code", rcode),
                attribute.String("type", dns.TypeToString[qtype]),
            ),
        )
    }

    // ... duration tracking ...
}
```

**Prometheus Output:**
```
# HELP dns_response_code_total DNS queries by response code
# TYPE dns_response_code_total counter
dns_response_code_total{code="NOERROR",type="A"} 1234
dns_response_code_total{code="NXDOMAIN",type="A"} 567
dns_response_code_total{code="SERVFAIL",type="A"} 12
dns_response_code_total{code="SERVFAIL",type="AAAA"} 5
```

### 3. Response Writer Wrapper

**Purpose:** Intercept response to capture response code

```go
// pkg/dns/response_writer.go (NEW FILE)

package dns

import (
    "net"
    "github.com/miekg/dns"
)

// responseCapturingWriter wraps dns.ResponseWriter to capture the response
type responseCapturingWriter struct {
    dns.ResponseWriter
    msg *dns.Msg  // Captured response
}

// WriteMsg captures the response message before writing
func (w *responseCapturingWriter) WriteMsg(m *dns.Msg) error {
    w.msg = m.Copy()  // Capture response
    return w.ResponseWriter.WriteMsg(m)
}

// Write is a fallback for raw writes (shouldn't be used in normal operation)
func (w *responseCapturingWriter) Write(b []byte) (int, error) {
    return w.ResponseWriter.Write(b)
}

// RemoteAddr delegates to wrapped writer
func (w *responseCapturingWriter) RemoteAddr() net.Addr {
    return w.ResponseWriter.RemoteAddr()
}

// LocalAddr delegates to wrapped writer
func (w *responseCapturingWriter) LocalAddr() net.Addr {
    return w.ResponseWriter.LocalAddr()
}

// Close delegates to wrapped writer
func (w *responseCapturingWriter) Close() error {
    return w.ResponseWriter.Close()
}

// TsigStatus delegates to wrapped writer
func (w *responseCapturingWriter) TsigStatus() error {
    return w.ResponseWriter.TsigStatus()
}

// TsigTimersOnly delegates to wrapped writer
func (w *responseCapturingWriter) TsigTimersOnly(b bool) {
    w.ResponseWriter.TsigTimersOnly(b)
}

// Hijack delegates to wrapped writer
func (w *responseCapturingWriter) Hijack() {
    w.ResponseWriter.Hijack()
}
```

### 4. Update Query Logging

**Add Response Code to Query Log:**

```go
// pkg/storage/sqlite.go

type QueryLog struct {
    // ... existing fields ...
    ResponseCode   string `json:"response_code"`  // NEW: NOERROR, SERVFAIL, NXDOMAIN, etc.
}

// Schema migration
const schemaV2 = `
ALTER TABLE query_logs ADD COLUMN response_code TEXT;

CREATE INDEX idx_query_logs_response_code ON query_logs(response_code);
`
```

**Handler Changes:**
```go
// pkg/dns/handler.go

func (h *Handler) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.Msg) {
    // ... query processing ...

    // Log query with response code
    if h.storage != nil {
        _ = h.storage.LogQuery(ctx, &storage.QueryLog{
            // ... existing fields ...
            ResponseCode: dns.RcodeToString[resp.Rcode],  // NEW
        })
    }
}
```

---

## Implementation Plan

### Phase 1: Fix SERVFAIL Handling (Critical)

**Files to modify:**
1. `pkg/forwarder/forwarder.go` - Remove SERVFAIL retry logic
2. `pkg/forwarder/forwarder_test.go` - Add DNSSEC test cases

**Tasks:**
- [ ] Update `Forward()` to return SERVFAIL immediately
- [ ] Update `ForwardTCP()` to return SERVFAIL immediately
- [ ] Update `ForwardWithUpstreams()` to return SERVFAIL immediately
- [ ] Add `isDNSSECQuery()` helper
- [ ] Add test for DNSSEC SERVFAIL pass-through
- [ ] Add test for network error retry

**Test Cases:**
```go
func TestForwarder_SERVFAIL_PassThrough(t *testing.T) {
    // When upstream returns SERVFAIL, should pass through immediately
    // Not retry with next upstream
}

func TestForwarder_SERVFAIL_DNSSEC(t *testing.T) {
    // DNSSEC query with broken signature
    // Should return SERVFAIL from first upstream
}

func TestForwarder_NetworkError_Retry(t *testing.T) {
    // Network timeout should retry next upstream
}
```

### Phase 2: Add Response Code Metrics

**Files to modify:**
1. `pkg/telemetry/telemetry.go` - Add DNSResponseCodeTotal metric
2. `pkg/dns/server_impl.go` - Record response codes
3. `pkg/dns/response_writer.go` - NEW: Response capturing wrapper

**Tasks:**
- [ ] Add DNSResponseCodeTotal counter to Metrics struct
- [ ] Initialize counter in New()
- [ ] Create responseCapturingWriter wrapper
- [ ] Wrap ResponseWriter in serveDNS()
- [ ] Record response code after handler completes
- [ ] Add tests for metric recording

### Phase 3: Update Query Logging

**Files to modify:**
1. `pkg/storage/sqlite.go` - Add response_code column
2. `pkg/storage/storage.go` - Update QueryLog struct
3. `pkg/dns/handler.go` - Pass response code to LogQuery()

**Tasks:**
- [ ] Add response_code column to schema
- [ ] Create migration for existing databases
- [ ] Update QueryLog struct
- [ ] Update LogQuery calls
- [ ] Add response_code to API responses

### Phase 4: Update Web UI

**Files to modify:**
1. `pkg/api/ui/templates/queries.html` - Show response code
2. `pkg/api/ui/static/app.js` - Filter by response code

**Tasks:**
- [ ] Add response code column to query table
- [ ] Add response code filter dropdown
- [ ] Color-code response codes (red for SERVFAIL, yellow for NXDOMAIN)
- [ ] Add response code to stats dashboard

### Phase 5: Documentation

**Files to create/update:**
1. `docs/guide/dnssec.md` - NEW: DNSSEC validation guide
2. `docs/api/metrics.md` - Document new metrics
3. `CHANGELOG.md` - v0.7.8 changes

---

## Testing Strategy

### Unit Tests

```go
// pkg/forwarder/forwarder_test.go
func TestForwarder_SERVFAIL_DNSSEC(t *testing.T)
func TestForwarder_SERVFAIL_NoRetry(t *testing.T)

// pkg/dns/server_impl_test.go
func TestResponseCodeMetrics(t *testing.T)
func TestResponseCapturingWriter(t *testing.T)
```

### Integration Tests

```go
// test/integration_test.go
func TestIntegration_DNSSEC_SERVFAIL(t *testing.T) {
    // Real DNSSEC query
    // Verify SERVFAIL is returned
    // Check metrics show SERVFAIL count
}

func TestIntegration_ResponseCodeMetrics(t *testing.T) {
    // Query various domains
    // Verify all response codes are tracked
}
```

### Manual Testing

```bash
# Test 1: DNSSEC SERVFAIL
dig @localhost sigfail.ippacket.stream +dnssec
# Expected: SERVFAIL immediately (no retry delay)

# Test 2: Check metrics
curl http://localhost:9090/metrics | grep dns_response_code_total
# Expected: See SERVFAIL counter

# Test 3: Check query log
curl http://localhost:8080/api/queries?limit=10
# Expected: See response_code field

# Test 4: Web UI
# Open http://localhost:8080/queries
# Expected: See response code column
```

---

## Metrics to Monitor

### Before v0.7.8

```bash
# Current metrics (incomplete)
dns_queries_total 1595
dns_queries_blocked_total 4
dns_queries_forwarded_total 321
```

### After v0.7.8

```bash
# Complete metrics
dns_queries_total 2000
dns_queries_blocked_total 50
dns_queries_forwarded_total 1500

# NEW: Response codes
dns_response_code_total{code="NOERROR"} 1800
dns_response_code_total{code="NXDOMAIN"} 150
dns_response_code_total{code="SERVFAIL"} 30
dns_response_code_total{code="FORMERR"} 5
dns_response_code_total{code="REFUSED"} 15
```

---

## Grafana Dashboard Updates

**New Panels:**

1. **DNS Response Codes (Pie Chart)**
   - Shows distribution of NOERROR, NXDOMAIN, SERVFAIL
   - Helps identify DNSSEC issues

2. **SERVFAIL Rate (Graph)**
   - Rate of SERVFAIL responses over time
   - Alert if > 5% of queries

3. **Response Code Timeline (Stacked Area)**
   - Shows response code trends
   - Identify patterns

**Alerts:**
```yaml
# High SERVFAIL rate
- alert: HighSERVFAILRate
  expr: rate(dns_response_code_total{code="SERVFAIL"}[5m]) / rate(dns_queries_total[5m]) > 0.05
  for: 10m
  annotations:
    summary: "High SERVFAIL rate (DNSSEC issues?)"
```

---

## Breaking Changes

**None expected** - All changes are backwards compatible:
- SERVFAIL behavior change improves correctness
- New metrics don't break existing dashboards
- Query log schema is additive (migration adds column)
- API responses gain new fields (backwards compatible)

---

## Performance Impact

### SERVFAIL No-Retry

**Before:**
- SERVFAIL â†’ retry 2nd upstream â†’ retry 3rd upstream â†’ return SERVFAIL
- Latency: 2-6 seconds (timeouts + retries)

**After:**
- SERVFAIL â†’ return immediately
- Latency: < 100ms (single upstream query)

**Impact:** ðŸš€ 10-50x faster SERVFAIL responses

### Response Code Tracking

**Overhead:**
- Response writer wrapper: ~100ns (negligible)
- Metric recording: ~200ns (counter increment)
- Total overhead: < 1Î¼s per query

**Impact:** âœ… Negligible performance impact

---

## Rollout Plan

1. **v0.7.8-beta1**: Internal testing with DNSSEC domains
2. **v0.7.8-beta2**: Community testing, gather feedback
3. **v0.7.8**: Stable release

**Rollback:** Previous behavior can be simulated by configuring multiple identical upstreams (natural retries)

---

## Success Criteria

- âœ… DNSSEC SERVFAIL returns in < 500ms (no retries)
- âœ… Response code metrics appear in Prometheus
- âœ… Query log shows response codes
- âœ… Web UI displays response codes
- âœ… All tests pass (including new DNSSEC tests)
- âœ… Performance overhead < 1Î¼s per query
- âœ… Zero breaking changes for users

---

## Related Issues

- #42: DNSSEC validation not working correctly
- #108: Missing response code metrics
- #156: Query log incomplete

---

## References

- [RFC 4035](https://datatracker.ietf.org/doc/html/rfc4035) - DNSSEC Protocol
- [RFC 4697](https://datatracker.ietf.org/doc/html/rfc4697) - Observed DNS Behavior
- [DNSSEC Test Domains](https://dnssec-debugger.verisignlabs.com/)
- Test domain: `sigfail.ippacket.stream` (broken DNSSEC)
- Test domain: `sigok.ippacket.stream` (valid DNSSEC)

---

**Next Steps:**
1. Review this plan
2. Create GitHub issue/milestone for v0.7.8
3. Begin Phase 1 implementation
4. Set up DNSSEC test environment
